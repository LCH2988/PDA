// Google Sheets BOGO 團隊分析 API
const SHEET_NAME = '訂單資料庫';
const REPORT_SHEET_NAME = '搶購回報紀錄';
const MAINTENANCE_SHEET_NAME = '上線維護';

function doGet(e) {
  try {
    const action = e.parameter.action || 'getOrders';
    
    switch(action) {
      case 'getOrders':
        return getOrders();
      case 'getReports':
        return getReports();
      case 'getMaintenance':
        return getMaintenance();
      case 'test':
        return testConnection();
      default:
        return createResponse(false, '未知的操作');
    }
  } catch (error) {
    return createResponse(false, error.toString());
  }
}

// 取得訂單資料
function getOrders() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_NAME);
  
  if (!sheet) {
    return createResponse(false, '找不到工作表：' + SHEET_NAME);
  }
  
  const lastRow = sheet.getLastRow();
  
  if (lastRow < 2) {
    return createResponse(true, []);
  }
  
  // 讀取所有欄位（A到Q欄，共17欄）
  const data = sheet.getRange(2, 1, lastRow - 1, 17).getValues();
  
  const orders = data.map((row, index) => {
    if (!row[2]) return null; // 如果沒有 LINE名稱，跳過
    
    return {
      訂購編號: row[0],
      個人ID: row[1],
      LINE名稱: row[2],
      組別代號: row[3],
      訂購數量: row[4],
      單價: row[5],
      PV: row[6],
      團購案: row[7],
      組別: row[8],
      '產品名稱( BOGO專用 )': row[9],
      '買 A': row[10],
      '送 B': row[11],
      '2022/11/17': row[12],
      LINE名稱2: row[13],
      群組: row[14],
      合計: row[15],
      團隊: row[16]
    };
  }).filter(order => order !== null);
  
  return createResponse(true, orders);
}

// 取得搶購回報資料
function getReports() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(REPORT_SHEET_NAME);
  
  if (!sheet) {
    return createResponse(false, '找不到工作表：' + REPORT_SHEET_NAME);
  }
  
  const lastRow = sheet.getLastRow();
  
  if (lastRow < 2) {
    return createResponse(true, []);
  }
  
  // 讀取所有欄位（A到J欄，共10欄）
  const data = sheet.getRange(2, 1, lastRow - 1, 10).getValues();
  
  const reports = data.map((row, index) => {
    if (!row[3]) return null; // 如果沒有搶購者，跳過
    
    return {
      編號: row[0],
      組別代號: row[1],
      搶購組數: row[2],
      搶購者: row[3],
      單價: row[4],
      PV數: row[5],
      '買/送': row[6],
      '搶購帳號/備註': row[7],
      團隊: row[8],
      群組ID: row[9]
    };
  }).filter(report => report !== null);
  
  return createResponse(true, reports);
}

// 取得上線維護資料
function getMaintenance() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(MAINTENANCE_SHEET_NAME);
  
  if (!sheet) {
    return createResponse(false, '找不到工作表：' + MAINTENANCE_SHEET_NAME);
  }
  
  const lastRow = sheet.getLastRow();
  
  if (lastRow < 2) {
    return createResponse(true, []);
  }
  
  // 讀取 F 欄（訂購名單）和 I 欄（團隊）
  const dataF = sheet.getRange(2, 6, lastRow - 1, 1).getValues(); // F 欄
  const dataI = sheet.getRange(2, 9, lastRow - 1, 1).getValues(); // I 欄
  
  const maintenance = [];
  for (let i = 0; i < dataF.length; i++) {
    if (dataF[i][0]) { // 如果訂購名單不為空
      maintenance.push({
        訂購名單: dataF[i][0],
        團隊: dataI[i][0] || ''
      });
    }
  }
  
  return createResponse(true, maintenance);
}

// 測試連線
function testConnection() {
  const sheet1 = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_NAME);
  const sheet2 = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(REPORT_SHEET_NAME);
  const sheet3 = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(MAINTENANCE_SHEET_NAME);
  
  return createResponse(true, {
    message: '連線成功！',
    spreadsheetName: SpreadsheetApp.getActiveSpreadsheet().getName(),
    sheets: {
      orders: {
        name: SHEET_NAME,
        exists: sheet1 !== null,
        rows: sheet1 ? sheet1.getLastRow() : 0
      },
      reports: {
        name: REPORT_SHEET_NAME,
        exists: sheet2 !== null,
        rows: sheet2 ? sheet2.getLastRow() : 0
      },
      maintenance: {
        name: MAINTENANCE_SHEET_NAME,
        exists: sheet3 !== null,
        rows: sheet3 ? sheet3.getLastRow() : 0
      }
    },
    timestamp: new Date().toISOString()
  });
}

// 建立回應
function createResponse(success, data) {
  const response = {
    success: success,
    data: data,
    timestamp: new Date().toISOString()
  };
  
  return ContentService
    .createTextOutput(JSON.stringify(response))
    .setMimeType(ContentService.MimeType.JSON);
}
