<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>語音聲學分析系統</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .control-group h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        button {
            width: 100%;
            padding: 12px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .btn-record {
            background: #dc3545;
            color: white;
        }

        .btn-record:hover {
            background: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(220, 53, 69, 0.3);
        }

        .btn-record.recording {
            background: #28a745;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .btn-play {
            background: #007bff;
            color: white;
        }

        .btn-play:hover {
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.3);
        }

        .btn-play:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .btn-upload {
            background: #17a2b8;
            color: white;
        }

        .btn-upload:hover {
            background: #138496;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(23, 162, 184, 0.3);
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
            height: 8px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .value-display {
            text-align: center;
            font-size: 1.2em;
            color: #667eea;
            font-weight: bold;
            margin-top: 5px;
        }

        .canvas-container {
            margin: 20px 0;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e9ecef;
        }

        .canvas-container h3 {
            color: #495057;
            margin-bottom: 15px;
        }

        canvas {
            width: 100%;
            height: 200px;
            background: white;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .info-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .info-card h4 {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .info-card .value {
            font-size: 1.8em;
            font-weight: bold;
        }

        input[type="file"] {
            display: none;
        }

        .status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .status.recording {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .status.playing {
            background: #d1ecf1;
            color: #0c5460;
            border: 2px solid #bee5eb;
        }

        .status.idle {
            background: #f8f9fa;
            color: #6c757d;
            border: 2px solid #e9ecef;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎙️ 語音聲學分析系統</h1>
        
        <div id="status" class="status idle">準備就緒</div>

        <div class="control-panel">
            <div class="control-group">
                <h3>📹 錄音控制</h3>
                <button id="recordBtn" class="btn-record">開始錄音</button>
                <button id="playBtn" class="btn-play" disabled>播放錄音</button>
            </div>

            <div class="control-group">
                <h3>📁 檔案上傳</h3>
                <button class="btn-upload" onclick="document.getElementById('fileInput').click()">
                    上傳音訊檔案
                </button>
                <input type="file" id="fileInput" accept="audio/*">
                <div style="margin-top: 10px; font-size: 0.9em; color: #6c757d;">
                    支援: MP3, WAV, OGG
                </div>
            </div>

            <div class="control-group">
                <h3>⚡ 播放速度</h3>
                <input type="range" id="speedControl" min="0.25" max="2" step="0.25" value="1">
                <div class="value-display"><span id="speedValue">1.0</span>x</div>
            </div>

            <div class="control-group">
                <h3>🔊 音量控制</h3>
                <input type="range" id="volumeControl" min="0" max="100" value="80">
                <div class="value-display"><span id="volumeValue">80</span>%</div>
            </div>
        </div>

        <div class="canvas-container">
            <h3>📊 波形圖 (Waveform)</h3>
            <canvas id="waveformCanvas"></canvas>
        </div>

        <div class="canvas-container">
            <h3>🌈 頻譜圖 (Frequency Spectrum)</h3>
            <canvas id="spectrumCanvas"></canvas>
        </div>

        <div class="info-panel">
            <div class="info-card">
                <h4>錄音時長</h4>
                <div class="value" id="duration">0.0s</div>
            </div>
            <div class="info-card">
                <h4>採樣率</h4>
                <div class="value" id="sampleRate">-</div>
            </div>
            <div class="info-card">
                <h4>平均頻率</h4>
                <div class="value" id="avgFreq">- Hz</div>
            </div>
            <div class="info-card">
                <h4>峰值振幅</h4>
                <div class="value" id="peakAmp">-</div>
            </div>
        </div>
    </div>

    <script>
        let audioContext;
        let analyser;
        let microphone;
        let mediaRecorder;
        let audioChunks = [];
        let audioBuffer;
        let source;
        let isRecording = false;
        let isPlaying = false;
        let animationId;
        let recordingStartTime;

        const recordBtn = document.getElementById('recordBtn');
        const playBtn = document.getElementById('playBtn');
        const speedControl = document.getElementById('speedControl');
        const volumeControl = document.getElementById('volumeControl');
        const speedValue = document.getElementById('speedValue');
        const volumeValue = document.getElementById('volumeValue');
        const fileInput = document.getElementById('fileInput');
        const statusDiv = document.getElementById('status');

        const waveformCanvas = document.getElementById('waveformCanvas');
        const spectrumCanvas = document.getElementById('spectrumCanvas');
        const waveformCtx = waveformCanvas.getContext('2d');
        const spectrumCtx = spectrumCanvas.getContext('2d');

        // 初始化 Canvas 尺寸
        function resizeCanvas() {
            waveformCanvas.width = waveformCanvas.offsetWidth;
            waveformCanvas.height = 200;
            spectrumCanvas.width = spectrumCanvas.offsetWidth;
            spectrumCanvas.height = 200;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // 初始化音訊上下文
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                document.getElementById('sampleRate').textContent = 
                    (audioContext.sampleRate / 1000).toFixed(1) + 'kHz';
            }
        }

        // 更新狀態
        function updateStatus(text, type) {
            statusDiv.textContent = text;
            statusDiv.className = `status ${type}`;
        }

        // 錄音功能
        recordBtn.addEventListener('click', async () => {
            if (!isRecording) {
                try {
                    initAudioContext();
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    recordingStartTime = Date.now();

                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        const arrayBuffer = await audioBlob.arrayBuffer();
                        audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        playBtn.disabled = false;
                        updateDuration();
                        visualizeWaveform(audioBuffer);
                    };

                    // 設置分析器用於即時視覺化
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                    microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);

                    mediaRecorder.start();
                    isRecording = true;
                    recordBtn.textContent = '停止錄音';
                    recordBtn.classList.add('recording');
                    updateStatus('🔴 錄音中...', 'recording');
                    
                    visualizeRecording();
                } catch (err) {
                    alert('無法存取麥克風: ' + err.message);
                }
            } else {
                mediaRecorder.stop();
                microphone.disconnect();
                isRecording = false;
                recordBtn.textContent = '開始錄音';
                recordBtn.classList.remove('recording');
                updateStatus('錄音完成', 'idle');
                cancelAnimationFrame(animationId);
            }
        });

        // 播放功能
        playBtn.addEventListener('click', () => {
            if (!isPlaying && audioBuffer) {
                initAudioContext();
                
                source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                
                const gainNode = audioContext.createGain();
                gainNode.gain.value = volumeControl.value / 100;
                
                source.playbackRate.value = parseFloat(speedControl.value);
                
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                
                source.connect(gainNode);
                gainNode.connect(analyser);
                analyser.connect(audioContext.destination);
                
                source.start(0);
                isPlaying = true;
                playBtn.textContent = '停止播放';
                updateStatus('▶️ 播放中...', 'playing');
                
                visualizePlaying();
                
                source.onended = () => {
                    isPlaying = false;
                    playBtn.textContent = '播放錄音';
                    updateStatus('準備就緒', 'idle');
                    cancelAnimationFrame(animationId);
                    visualizeWaveform(audioBuffer);
                };
            } else if (isPlaying) {
                source.stop();
                isPlaying = false;
                playBtn.textContent = '播放錄音';
                updateStatus('準備就緒', 'idle');
                cancelAnimationFrame(animationId);
            }
        });

        // 速度控制
        speedControl.addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            speedValue.textContent = speed.toFixed(2);
            if (source && isPlaying) {
                source.playbackRate.value = speed;
            }
        });

        // 音量控制
        volumeControl.addEventListener('input', (e) => {
            volumeValue.textContent = e.target.value;
        });

        // 檔案上傳
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                initAudioContext();
                const arrayBuffer = await file.arrayBuffer();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                playBtn.disabled = false;
                updateStatus('檔案載入成功', 'idle');
                updateDuration();
                visualizeWaveform(audioBuffer);
            }
        });

        // 更新時長資訊
        function updateDuration() {
            if (audioBuffer) {
                const duration = audioBuffer.duration;
                document.getElementById('duration').textContent = duration.toFixed(2) + 's';
            }
        }

        // 視覺化錄音
        function visualizeRecording() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const freqArray = new Uint8Array(bufferLength);

            function draw() {
                animationId = requestAnimationFrame(draw);

                analyser.getByteTimeDomainData(dataArray);
                analyser.getByteFrequencyData(freqArray);

                // 繪製波形
                waveformCtx.fillStyle = 'rgb(255, 255, 255)';
                waveformCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
                waveformCtx.lineWidth = 2;
                waveformCtx.strokeStyle = 'rgb(102, 126, 234)';
                waveformCtx.beginPath();

                const sliceWidth = waveformCanvas.width / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * waveformCanvas.height / 2;

                    if (i === 0) {
                        waveformCtx.moveTo(x, y);
                    } else {
                        waveformCtx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                waveformCtx.lineTo(waveformCanvas.width, waveformCanvas.height / 2);
                waveformCtx.stroke();

                // 繪製頻譜
                drawSpectrum(freqArray);
                updateFrequencyInfo(freqArray);
            }

            draw();
        }

        // 視覺化播放
        function visualizePlaying() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const freqArray = new Uint8Array(bufferLength);

            function draw() {
                if (!isPlaying) return;
                animationId = requestAnimationFrame(draw);

                analyser.getByteTimeDomainData(dataArray);
                analyser.getByteFrequencyData(freqArray);

                // 繪製波形
                waveformCtx.fillStyle = 'rgb(255, 255, 255)';
                waveformCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
                waveformCtx.lineWidth = 2;
                waveformCtx.strokeStyle = 'rgb(102, 126, 234)';
                waveformCtx.beginPath();

                const sliceWidth = waveformCanvas.width / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * waveformCanvas.height / 2;

                    if (i === 0) {
                        waveformCtx.moveTo(x, y);
                    } else {
                        waveformCtx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                waveformCtx.lineTo(waveformCanvas.width, waveformCanvas.height / 2);
                waveformCtx.stroke();

                // 繪製頻譜
                drawSpectrum(freqArray);
                updateFrequencyInfo(freqArray);
            }

            draw();
        }

        // 繪製靜態波形
        function visualizeWaveform(buffer) {
            const data = buffer.getChannelData(0);
            const step = Math.ceil(data.length / waveformCanvas.width);
            const amp = waveformCanvas.height / 2;

            waveformCtx.fillStyle = 'rgb(255, 255, 255)';
            waveformCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            waveformCtx.lineWidth = 1;
            waveformCtx.strokeStyle = 'rgb(102, 126, 234)';
            waveformCtx.beginPath();

            let maxAmp = 0;

            for (let i = 0; i < waveformCanvas.width; i++) {
                let min = 1.0;
                let max = -1.0;

                for (let j = 0; j < step; j++) {
                    const datum = data[(i * step) + j];
                    if (datum < min) min = datum;
                    if (datum > max) max = datum;
                }

                maxAmp = Math.max(maxAmp, Math.abs(max), Math.abs(min));

                const yLow = (1 + min) * amp;
                const yHigh = (1 + max) * amp;

                waveformCtx.moveTo(i, yLow);
                waveformCtx.lineTo(i, yHigh);
            }

            waveformCtx.stroke();

            document.getElementById('peakAmp').textContent = maxAmp.toFixed(3);
        }

        // 繪製頻譜
        function drawSpectrum(freqArray) {
            spectrumCtx.fillStyle = 'rgb(255, 255, 255)';
            spectrumCtx.fillRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);

            const barWidth = (spectrumCanvas.width / freqArray.length) * 2.5;
            let x = 0;

            for (let i = 0; i < freqArray.length; i++) {
                const barHeight = (freqArray[i] / 255) * spectrumCanvas.height;
                
                const hue = (i / freqArray.length) * 360;
                spectrumCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                spectrumCtx.fillRect(x, spectrumCanvas.height - barHeight, barWidth, barHeight);

                x += barWidth + 1;
            }
        }

        // 更新頻率資訊
        function updateFrequencyInfo(freqArray) {
            let sum = 0;
            let count = 0;

            for (let i = 0; i < freqArray.length; i++) {
                if (freqArray[i] > 0) {
                    sum += i * freqArray[i];
                    count += freqArray[i];
                }
            }

            if (count > 0) {
                const avgBin = sum / count;
                const nyquist = audioContext.sampleRate / 2;
                const avgFreq = (avgBin / freqArray.length) * nyquist;
                document.getElementById('avgFreq').textContent = Math.round(avgFreq) + ' Hz';
            }
        }
    </script>
</body>
</html>
